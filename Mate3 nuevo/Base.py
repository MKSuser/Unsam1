# -*- coding: utf-8 -*-
"""TP Final para ver el viernes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tmzo2lEZDN0KQeiHOUBIe1EpQ42GeQmR

#**<u>Clasificación Estelar</u>**

###Desde siempre hemos mirado al cielo pensando en ¿quiénes somos? ¿por qué estamos aquí? ¿Qué son las estrellas?, en base a estas preguntas y otras más profundas y específicas, nace el estudio de los astros: la astronomía.
###En la Astronomía, la clasificación estelar se basa en características espectrales observables. Algunas de estas características son: filtro ultravioleta, filtro infrarrojo, corrimiento al rojo, etc.
###¿Pero es posible en base a estas características identificar estos objetos?
###Con esta pregunta en nuestras cabezas, elegimos un data frame que es un conjunto de 100.000 observaciones del espacio, obtenidas de la SDSS (Sloan Digital Sky Survey), el cúal es proyecto de investigación del espacio mediante imágenes en el espectro visible y de corrimiento rojo, realizadas en el telescopio Apache Point de Nuevo México.
###Cada observación se describe en 17 columnas de características y 1 columna de clase que identifica a cada observación como estrella, galaxia o cuásar (galaxia recién nacida o bien la energía del agujero negro del centro de la galaxia recien nacida).

##<u>Columnas:</u>
####1- obj_ID = Identificador único de cada objeto
####2- alpha = Ángulo de ascensión derecha
####3- delta = Ángulo de declinación
####4- u = Filtro ultravioleta
####5- g = Filtro verde
####6- r = Filtro rojo
####7- i = Filtro infrarrojo cercano en el sistema fotométrico
####8- z = Filtro infrarrojo en el sistema fotométrico
####9- run_ID = Número de ejecución utilizado para identificar el análisis específico
####10- rereun_ID = Número de repetición para especificar cómo se procesó la imagen
####11- cam_col = Columna de cámara para identificar la línea de exploración dentro de la ejecución
####12- field_ID = Número de campo para identificar cada campo
####13- spec_obj_ID = Identificador único utilizado para objetos espectroscópicos ópticos (esto significa que 2 observaciones diferentes con el mismo spec_obj_ID deben compartir la clase de salida)
####14- class = Clase del objeto (galaxia, estrella o cuásar)
###15- redshift = Valor de corrimiento al rojo basado en el aumento de la longitud de onda
####16- plate = Identificador de placa del SDSS
####17- MJD = Fecha utilizada para indicar cuándo se tomó un determinado dato del SDSS
####18- fiber_ID = Identificador de fibra que apuntó la luz al plano focal en cada observación
"""

# Empecemos!

# Cargamos las librerías con las que vamos a trabajar

import pandas as pd
import seaborn as sns
import numpy as np
import matplotlib.pyplot as plt

# Declaramos la base de datos y la volvemos "df" para poder manipularla

df = pd.read_csv('https://raw.githubusercontent.com/MKSuser/Unsam1/refs/heads/main/TP%20Mate3/star_classification.csv')

# Pinteamos los nombres de las columnas con las que vamos a trabajar

print(df.columns)

# Para poder trabajar con datos mas comprensibles, cambiamos los nombres de las columnas

df.rename(columns={'obj_ID': 'Id del objeto',
                   'alpha': 'Ang Asc Derecha',
                  'delta': 'Ang Declinación',
                   'u': 'Filtro ultravioleta',
                   'g':'Filtro verde',
                   'r': 'Filtro Rojo',
                   'i': 'Filtro Inf. cercano',
                   'z': 'Filtro Inf.',
                   'run_ID': 'Id de Analisis',
                   'rerun_ID': 'Id de repetición',
                   'cam_col': 'Columna de cámara',
                   'field_ID': 'Id de campo',
                   'spec_obj_ID': 'Id',
                   'class': 'Clase',
                   'redshift': 'Corrimiento al Rojo',
                   'plate': 'Id de plada SDSS',
                   'MJD': 'Fecha del dato',
                   'fiber_ID': 'Id de fibra',

                   },inplace=True)

# Podemos observar con mejor detalle el tipo de las variables que ocupan cada columna

df.info()

# Obtenemos 5 muestras random para poder observar como están compuestas

df.sample(5)

# Sabiendo que lo que buscamos es poder determinar es lo que se encuentra en la colmuna "class",
#  obtenemos qué clases (output) hay y cuántos resultados hay de cada una.

df["Clase"].value_counts()

# Por si llegan a haber muestras sin datos, los limpiamos. Si no hay NaN no va a pasar nada.

df = df.dropna()

df["Clase"].value_counts()

# Observamos que contamos con la misma cantiadad de resultados, por lo que no habría ningún NaN.

# Entre los datos de la base, nos encontramos con que el output se determina con las palabras "GALAXY" (galaxia), "STAR" (estrella) y "QSO" (Objeto cuasi estelar).
# Para poder buscar correlatividades, convertimos estas palabras en los valores 0, 1 y 2.
# Generamos un diccinario para poder reemp los datos

class_rep = {
     "GALAXY": 0,
     "STAR":   1,
     "QSO":    2,
}

# Generamos un nuevo df para poder hacer pruebas

df_limpio = df

# Reemplazamos los datos del diccionario "class_rep" por los que figuran en la colmuna "class"

df_limpio['Clase'] = df_limpio['Clase'].replace(class_rep)

# Movemos la columna 'Clase' al final previendo que la vamos a necesitar en la red neuronal
df_limpio = df_limpio[[col for col in df.columns if col != 'Clase'] + ['Clase']]

# Verifiamos que en la nueva base tenemos valores numericos en la columna "class" en lugar de texto

df_limpio.sample(5)

# Imprimimos los histogramas de cada columna para poder evaluar distribución de datos.

df_limpio.hist(figsize=(10, 10))

# Como observamos datos variados optamos por trabajarlo por cuartiles, de esta manera alejamos valores atípicos

df_limpio_salida = df_limpio['Clase']
df_limpio_red = df_limpio['Corrimiento al Rojo']

# Primero separamos los cuartiles teniendo encuenta antes del 25%, y luego del 75%
Q1 = df_limpio.quantile(0.25)
Q3 = df_limpio.quantile(0.75)

# Tomamos la diferencia para poder laburar
IQR = Q3 - Q1

# Identificar valores atípicos utilizando el criterio del IQR
atipicos = ((df_limpio < (Q1 - 1.5 * IQR)) | (df_limpio > (Q3 + 1.5 * IQR)))

# Con esto se pueden saber los valores
num_atipicos = atipicos.sum()
print("num_atipicos:\n", num_atipicos)

# Saco del df_limpio las filas con valores atípicos
df_limpio = df_limpio.where(np.invert(atipicos))

# Insertamos la columna de salida original
df_limpio['Clase'] = df_limpio_salida
df_limpio['Corrimiento al Rojo'] = df_limpio_red

df_limpio = df_limpio.dropna()

# Nuevos histogramas
df_limpio.hist(figsize=(15, 15))

# Emitimos una estadística rápida de los datos pero con datos normalizados

df_limpio_salida = df_limpio['Clase']

df_limpio_stats = df_limpio.describe().T
df_limpio_n = (df_limpio - df_limpio_stats['mean']) / df_limpio_stats['std']  # Para normalizar: (valor - promedio) / desv_estandar

df_limpio_n['Clase'] = df_limpio_salida

df_limpio_n.describe()

# Graficamos los valores de correlacion

fig, ax = plt.subplots(figsize=(10, 10))
sns.heatmap(df_limpio.corr(), annot=True, linewidths=0.5, fmt= '.2f',ax=ax)
ax.set_xticklabels(df_limpio.columns.to_list(), rotation=45, ha='right')
plt.title("Matriz de Correlaciones")
plt.show()

# Concluimos que hay una correlacion interesante con las siguientes colmunas:

# Filtro Ultravioleta, Filtro Rojo, Filtro Inf. Cercano, Filtro Inf. y Corrimiento al Rojo

# Prodecemos a achicar las columnas para poder trabajar de una manera mas eficiente

df_limpio = df_limpio.drop ('Id del objeto', axis = 1)
df_limpio = df_limpio.drop ('Ang Asc Derecha', axis = 1)
df_limpio = df_limpio.drop ('Ang Declinación', axis = 1)
# df_limpio = df_limpio.drop ('Filtro ultravioleta', axis = 1)
df_limpio = df_limpio.drop ('Filtro verde', axis = 1)
# df_limpio = df_limpio.drop ('Filtro Rojo', axis = 1)
# df_limpio = df_limpio.drop ('Filtro Inf. cercano', axis = 1)
# df_limpio = df_limpio.drop ('Filtro Inf.', axis = 1)
df_limpio = df_limpio.drop ('Id de Analisis', axis = 1)
df_limpio = df_limpio.drop ('Id de repetición', axis = 1)
df_limpio = df_limpio.drop ('Columna de cámara', axis = 1)
df_limpio = df_limpio.drop ('Id de campo', axis = 1)
df_limpio = df_limpio.drop ('Id', axis = 1)
df_limpio = df_limpio.drop ('Id de plada SDSS', axis = 1)
df_limpio = df_limpio.drop ('Fecha del dato', axis = 1)
df_limpio = df_limpio.drop ('Id de fibra', axis = 1)


fig, ax = plt.subplots(figsize=(5, 5))
sns.heatmap(df_limpio.corr(), annot=True, linewidths=0.5, fmt= '.2f',ax=ax)
ax.set_xticklabels(df_limpio.columns.to_list(), rotation=45, ha='right')
plt.title("Matriz de Correlaciones")
plt.show()
